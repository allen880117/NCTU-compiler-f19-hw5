# 作業 5 報告

> 學生：王祥任
>
> 學號：0616309

## 概要

終於來到最後一個階段，結合作業3的AST和作業4的Symbol Table，在本次作業5中，我們要產生 `P` 語言的 `RISC-V` 組合語言，完成Code Generation。

## 作業 5 心得

### 前言

由於作業3的時候就已經建構好了`AST`，而在作業4的時候也已經建構好了`Symbol Table`，在寫作業5的時候其實速度蠻快的。

作業5本質上就是為每一個節點撰寫匹配的組合語言，是一種一對一映照，所以最初的困難點其實會是在組合語言的撰寫上。

如果只要完成最基本的需求，那麼作業5附贈的`RISC-V`教學其實十分夠用了。但是如果考慮撰寫`BONUS`的話，難度基本是三級跳。

* 我到現在還是沒想出怎麼動態分配記憶體給字串。
* 但我也沒有時間寫了，QQ。

### BONUS

在寫`BONUS`的時候，附贈的教學就不太夠用了，這裡附上一個好用的PDF，基本上`RISC-V`的基本教學這裡面都有。

* [我是教學，我是中文的](http://crva.io/documents/RISC-V-Reader-Chinese-v2p1.pdf)

而在寫`Boolean`的部分是`Bonus`中最簡單的，基本上可以將其思考為只有兩種數字的`Integer`。

* `1` 為 `true` , `0` 為 `false`。

而`Array`因為必須處理多維度存取還有`Call by Reference`等情況，寫起來算是最為麻煩的。

而`Floating Point`的心路歷程比較神奇一點。最早的時候我以為要把`IEEE 754`重新看一遍，才能管理浮點數的記憶體。但後來我想起來一件事：

* 連 `ARM` 都有 `FPU` 的指令可以用了，我不相信`RISC-V`沒有。

結果我去翻了一下手冊，這才發現還真的有相應的`F`指令可以使用。

但這時又有一個麻煩的點冒出來了，浮點數是沒有`immediate`這東西可以使用了。但好險直接用`C`寫一個類似的結構，他就會示範給你看，該如何去載入浮點數的`immediate`。

* 其實是用`.float`去模擬。

### 小疑問

* 其實我有點不太理解限制 4bytes (32bits) 的理由

畢竟我們使用的 `RISC-V` 使用的是 8bytes (64bits) ， 如果使用 4bytes (32bits) 為單位去分配 Stack 就有可能產生沒有 Alignment 的問題。

舉個例子，Function 傳遞的 Parameter 數是 11 個， 後 3 個參數以放入 Stack 的方式傳遞，此時再 Jump 到 Print 函數 ， 就有可能產生 Access Error。

## 整學期編譯器作業心得

從 `SCANNER` `PARSER` `AST CONSTRUCTOR` `SEMANTIC ANALYZER` `CODE GENERATOR`，這樣一路跑下來，總算做出了一個粗糙的編譯器出來。

在撰寫編譯器的過程中，我覺得學到最多的是從另外一個角度去思考使用程式語言的方式。為何程式語言的語法結構會如此設定，為何程式語言的功能會有此種限制或延伸。這些問題都可以從更基底的角度去思考。

撰寫編譯器本身就是一種長期的程式挑戰，除了嘗試使用`Regular Expression`，我覺得我的物件導向能力又被重新訓練了一遍。

整學期的編譯器作業寫下來，最值得感謝的就是 `spec` 和 `discussion` ，像這類型的作業能夠有詳細的 `spec` 去定義所有的規約和準則是最棒的事，但同時必須考慮的項目就會大量增長，而 `discussion` 中的紀錄就有助於我們發現自己沒有察覺的問題。

雖然編譯器作業真的是 **`#compiler-f19撕心裂肺虐我的肝`** ，但成就感和學習到的東西也非同小可。尤其是作業三，我覺得這是我進大學後整合度最高的成果。

在這邊感謝 **`TA們`** 在 `Discussion` 努力地回答我們的問題，還有寫出那個稍有瑕疵，但瑕不掩瑜的`Spec`，多虧TA們，我們才寫得出這五份作業，謝謝。
